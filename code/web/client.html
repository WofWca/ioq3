<!DOCTYPE html><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>The Longest Yard</title>
<style>
html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: rgb(0, 0, 0); display:flex; align-items: center; justify-content: center; }
canvas { max-width: 100%; max-height: 100%; min-width: 100%; min-height: 100%; object-fit: contain; }
#progress { position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; width: 80%; height: 4em; background: black; border: .5em solid white; padding: .5em; }
#done { width: 0; height: 100%; background: white; }
</style>

<div id=progress style=display:none><div id=done></div></div>

<canvas id=canvas></canvas>

<script type=module>

const defaultKeyBindingKeyCodes = {
    "KeyW": true,
    "KeyA": true,
    "KeyS": true,
    "KeyD": true,
    "KeyC": true,
    "KeyT": true,
    "Digit1": true,
    "Digit2": true,
    "Digit3": true,
    "Digit4": true,
    "Digit5": true,
    "Digit6": true,
    "Digit7": true,
    "Digit8": true,
    "Digit9": true,
    "Tab": true,
    "Space": true,
    "Enter": true,
    "NumpadEnter": true,
    "Delete": true,
    "Slash": true,
    "Backslash": true,
    "ArrowUp": true,
    "ArrowDown": true,
    "ArrowLeft": true,
    "ArrowRight": true,
    "PageDown": true,
    "End": true,
    "Escape": true,
    "ControlLeft": true,
    "ControlRight": true,
    "ShiftLeft": true,
    "ShiftRight": true,
    "AltLeft": true,
    "AltRight": true
};
window.addEventListener("keydown", (e) => {
        // Emscripten SDL2 will preventDefault all keyboard events which prevents browser keyboard shortcuts from working.
        // This was supposed to be fixed in https://github.com/emscripten-core/emscripten/issues/16462 however the fix regressed.
        // This hack lets the browser handle everything, except for the default Quake III keybindings.
        if (!defaultKeyBindingKeyCodes[e.code]) e.preventDefault = () => false;
    }, { capture: true });

let { promise: demoq3pak0Promise, resolve: gotDemoq3pak0 } = Promise.withResolvers();

let generatedArguments = `
    +set r_mode -2
    +set fs_game demoq3
    +set cg_fovGunAdjust 1
    +set cg_fovAspectAdjust 1
    +set com_maxfps 0
    +set net_enabled 1
    +set net_peer_server "ws://localhost:8080/ws"
    +set r_fullscreen 0
    +connect peer_1.humblenet
`;
    // +map q3dm17
    // +addbot daemia 2
    // +addbot visor 2
    // +addbot sarge 2
    // +addbot stripe 2
    // +addbot major 2
    const buildPath = '../../build/debug-emscripten-wasm32';

import(`${buildPath}/ioquake3_opengl2.wasm32.js`).then((ioquake3)=>{
    ioquake3.default({
        canvas: canvas,
        arguments: generatedArguments.trim().split(/\s+/),
        locateFile: (file) => `${buildPath}/${file}`,
        preRun: [async (module) => {
            // Add the fetched asset files to the Emscripten virtual filesystem.
            module.addRunDependency('setup-ioq3-filesystem');
            module.FS.mkdirTree('/demoq3');
            module.FS.writeFile('/demoq3/pak0.pk3', await demoq3pak0Promise);
            progress.style.display = 'none';
            module.removeRunDependency('setup-ioq3-filesystem');
        }],
    });
});

// demoq3/pak0.pk3 is original Quake 3 demo assets. Fetch them from a tarfile in a gz file in a shell script in a zip file at the Internet Archive.
// First check to see if we have it in the cache
const cache = await caches.open('thelongestyard');
const cacheResponse = await cache.match('/demoq3/pak0.pk3');
let demoq3pak0 = await cacheResponse?.arrayBuffer();
if (demoq3pak0) {
    demoq3pak0 = new Uint8Array(demoq3pak0);
} else {
    progress.style.display = 'block';
    const demoSize = 49289300;
    let sh = await fetch('https://archive.org/download/tucows_286139_Quake_III_Arena/linuxq3ademo-1.11-6.x86.gz.zip/linuxq3ademo-1.11-6.x86.gz.sh').then(r => r.body);
    // Skip the first 0x155C bytes of the shell script to get the gz file. Ugh, the streams API is terrible.
    // Also update the progress bar.
    let downloaded = 0;
    let gz = sh.pipeThrough(new TransformStream({
        transform(chunk, controller) {
            const skip = 0x155C;
            if (downloaded >= skip) {
                downloaded += chunk.byteLength;
                done.style.width = `${downloaded / demoSize * 100}%`;
                controller.enqueue(chunk);
                return;
            }
            const chunkStart = downloaded;
            const chunkEnd = downloaded + chunk.byteLength;
            downloaded = chunkEnd;
            if (chunkEnd < skip) return;
            controller.enqueue(chunk.subarray(skip - chunkStart));
            done.style.width = `${downloaded / demoSize * 100}%`;
        }
    }));
    let tar = new Uint8Array(await new Response(gz.pipeThrough(new DecompressionStream('gzip'))).arrayBuffer());
    // the tar format is structured in 512 byte blocks. Read the blocks and find the pak0.pk3 file
    for (let offset = 0; offset < tar.byteLength;) {
        let name = String.fromCharCode.apply(null, tar.subarray(offset, offset + 100)).replace(/\0/g, '').trim();
        let size = parseInt(String.fromCharCode.apply(null, tar.subarray(offset + 124, offset + 136)).replace(/\0/g, '').trim(), 8);
        if (name === 'demoq3/pak0.pk3') {
            demoq3pak0 = tar.subarray(offset + 512, offset + 512 + size);
            cache.put('/demoq3/pak0.pk3', new Response(demoq3pak0, { headers: { 'Content-Type': 'application/octet-stream' } }));
            break;
        }
        offset += 512 + Math.ceil(size / 512) * 512;
    }
}
if (!demoq3pak0) throw new Error('demoq3/pak0.pk3 not found');
gotDemoq3pak0(demoq3pak0);

</script>
